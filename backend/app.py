# 1Ô∏è‚É£ ‡∏™‡πà‡∏ß‡∏ô Import Library
import folium
import streamlit as st
import random
import heapq
import json
import time
import streamlit.components.v1 as components
import math

import osmnx as ox
import os

import networkx as nx

from geopy.distance import geodesic 

from function.distance_real import *
from function_2.cbs_alogo import *
from function_2.osm_route import *
from function_2.create_map_2 import *
from function_2.compare_agent import *

from function_2.comparison_table import *

from function.statistics import *
from function.graph import *

from static_var.station_location import station_locations



import functools
import time



from function_2.m_star_Fame import *




# ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ñ‡∏ô‡∏ô‡∏à‡∏≤‡∏Å OpenStreetMap
# road = ox.graph_from_place("Lat Krabang, Bangkok, Thailand", network_type="all")
# ox.save_graphml(road, "lat_krabang_graph.graphml")

graph_file = "lat_krabang_graph.graphml"
if os.path.exists(graph_file):
    road = ox.load_graphml(graph_file)
else:
    # road = ox.graph_from_place("Lat Krabang, Bangkok, Thailand", network_type="all")
    road = ox.graph_from_place("Lat Krabang, Bangkok, Thailand", network_type="walk")
    ox.save_graphml(road, graph_file)







# def heuristic(a, b):
#     return math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2)

def heuristic(a, b):
    return geodesic(a, b).meters  # ‡πÉ‡∏ä‡πâ‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á geodesic ‡πÄ‡∏õ‡πá‡∏ô heuristic

# def heuristic(a, b):
#     return geodesic(a, b).meters


# üíåüßö‚Äç‚ôÄÔ∏èüíóüå®ü•°üç• üíåüßö new ü•°üç• üíåüßö‚Äç‚ôÄÔ∏èüíóüå®ü•°üç•
def create_station_graph(station_locations):
    """
    ‚õ∞üåøüåª‚òÄÔ∏è‚òÅÔ∏è
    ‡∏™‡∏£‡πâ‡∏≤‡∏á NetworkX graph object ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ
    
    Args:
        station_locations (list): List of station coordinates (lat, lon)
    
    Returns:
        nx.Graph: Complete graph connecting all stations
        
    ‚õ∞üåøüåª‚òÄÔ∏è‚òÅÔ∏è
    """
    G = nx.Graph()

   
    
    # ‡πÄ‡∏û‡∏¥‡πà‡∏° nodes (‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ)
    for station in station_locations:
        G.add_node(station)
    
    # ‡πÄ‡∏û‡∏¥‡πà‡∏° edges (‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ)
    for i, station1 in enumerate(station_locations):
        for station2 in station_locations[i+1:]:  # Avoid duplicate edges
            distance = geodesic(station1, station2).meters
            G.add_edge(station1, station2, weight=distance, length=distance)
    
    return G
# üíåüßö‚Äç‚ôÄÔ∏èüíóüå®ü•°üç• üíåüßö‚Äç‚ôÄÔ∏èüíóüå®ü•°üç• üíåüßö‚Äç‚ôÄÔ∏èüíóüå®ü•°üç•


# üß™üß™üß™ ‡πÉ‡∏ä‡πâ astar_path ‡∏Ç‡∏≠‡∏á networkX üß™üß™üß™
def a_star_search(graph, start, goal):
    """
    ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢ A* algorithm ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ NetworkX
    """
    try:
        # ‡πÉ‡∏ä‡πâ astar_path ‡∏à‡∏≤‡∏Å NetworkX
        path = nx.astar_path(graph, start, goal, weight='length')
        return path
    except nx.NetworkXNoPath:
        print(f"‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á {start} ‡πÅ‡∏•‡∏∞ {goal}")
        return []






# ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞
# 4Ô∏è‚É£ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô run_simulation() ‚Üí ‡∏£‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏≥‡∏•‡∏≠‡∏á
def run_simulation():
    num_persons = st.session_state.num_persons
    max_time_step = st.session_state.max_time_step_input
    num_bikes_per_station = st.session_state.num_bikes


    # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÄ‡∏î‡∏¥‡∏ô (‡πÄ‡∏ß‡∏•‡∏≤‡∏ï‡πà‡∏≠‡πÄ‡∏°‡∏ï‡∏£) ‡πÅ‡∏•‡∏∞ simulation time step (‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)
    t_per_meter = 0.1           # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏ß‡∏•‡∏≤ (‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ) ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÄ‡∏î‡∏¥‡∏ô 1 ‡πÄ‡∏°‡∏ï‡∏£
    simulation_time_step = 1    # 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏ï‡πà‡∏≠ time step


    # map boundaries
    min_lat = min(x[0] for x in station_locations)
    max_lat = max(x[0] for x in station_locations)
    min_lon = min(x[1] for x in station_locations)
    max_lon = max(x[1] for x in station_locations)

    

    # ‡∏™‡∏∏‡πà‡∏°‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏Ç‡∏≠‡∏á agent
    # ! ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏≤‡πÄ‡∏ä‡πá‡∏Å‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ‡∏ß‡πà‡∏≤ ‡∏Å‡∏≤‡∏£‡πÄ‡∏Å‡∏¥‡∏î ‡πÑ‡∏°‡πà‡∏Ñ‡∏ß‡∏£‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏î‡∏¥‡∏ô‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ
    start_positions = [
        (random.uniform(min_lat, max_lat), random.uniform(min_lon, max_lon))
        for _ in range(num_persons)
    ]
    destination_positions = [
        (random.uniform(min_lat, max_lat), random.uniform(min_lon, max_lon))
        for _ in range(num_persons)
    ]

    # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏£‡∏≤‡∏ü‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö A* Search ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ
    graph = create_station_graph(station_locations)

    # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏±‡∏Å‡∏£‡∏¢‡∏≤‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ
    initial_station_bikes = [num_bikes_per_station] * len(station_locations)

    full_paths_a_star = []  # ‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ç‡∏≠‡∏á‡∏ó‡∏∏‡∏Å agent ‡∏ó‡∏µ‡πà‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏î‡πâ‡∏ß‡∏¢‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏° A*
    rental_events = []      # ‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏´‡∏ï‡∏∏‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πà‡∏≤‡∏à‡∏±‡∏Å‡∏£‡∏¢‡∏≤‡∏ô (‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡πà‡∏≤, ‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡πà‡∏≤)
    return_events = []      # ‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏´‡∏ï‡∏∏‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏Å‡∏≤‡∏£‡∏Ñ‡∏∑‡∏ô‡∏à‡∏±‡∏Å‡∏£‡∏¢‡∏≤‡∏ô (‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏Ñ‡∏∑‡∏ô, ‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡∏ó‡∏µ‡πà‡∏Ñ‡∏∑‡∏ô)
    agent_grid_steps = []   # ‡πÄ‡∏Å‡πá‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô grid steps ‡∏ó‡∏µ‡πà‡πÅ‡∏ï‡πà‡∏•‡∏∞ agent ‡πÄ‡∏î‡∏¥‡∏ô‡∏à‡∏£‡∏¥‡∏á 

    for start_pos, dest_pos in zip(start_positions, destination_positions):
        print(f"A*: Agent ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏µ‡πà {start_pos} ‡πÅ‡∏•‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏õ‡∏ó‡∏µ‡πà {dest_pos}")

        # ‡∏à‡∏±‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ï‡∏≤‡∏°‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏à‡∏≤‡∏Å agent (‡πÉ‡∏Å‡∏•‡πâ‡πÑ‡∏õ‡πÑ‡∏Å‡∏•)
        sorted_stations = sorted(station_locations, key=lambda s: heuristic(start_pos, s))

        # ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏à‡∏±‡∏Å‡∏£‡∏¢‡∏≤‡∏ô‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏≠‡∏¢‡∏π‡πà ‡πÇ‡∏î‡∏¢‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏Å‡πà‡∏≠‡∏ô
        start_station = None
        for station in sorted_stations:
            station_index = station_locations.index(station)
            if initial_station_bikes[station_index] > 0:
                start_station = station
                break

        # ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡πÑ‡∏´‡∏ô‡∏°‡∏µ‡∏à‡∏±‡∏Å‡∏£‡∏¢‡∏≤‡∏ô‡πÄ‡∏•‡∏¢ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
        if start_station is None:
            start_station = sorted_stations[0]

        # ‡∏´‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏à‡∏∏‡∏î‡∏´‡∏°‡∏≤‡∏¢‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
        end_station = min(station_locations, key=lambda s: heuristic(dest_pos, s))

        # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á: ‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô ‚Üí ‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡πÄ‡∏ä‡πà‡∏≤ ‚Üí ‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡∏Ñ‡∏∑‡∏ô ‚Üí ‡∏à‡∏∏‡∏î‡∏´‡∏°‡∏≤‡∏¢‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á
        complete_path = [start_pos]

        # ‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡πÄ‡∏ä‡πà‡∏≤‡∏à‡∏±‡∏Å‡∏£‡∏¢‡∏≤‡∏ô
        osm_path_start = find_route_osm(road, start_pos, start_station, 'a_star')
        if osm_path_start:
            complete_path.extend(osm_path_start[1:])  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡πÄ‡∏ä‡πà‡∏≤

        # ‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡πÄ‡∏ä‡πà‡∏≤‡∏à‡∏±‡∏Å‡∏£‡∏¢‡∏≤‡∏ô‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡∏Ñ‡∏∑‡∏ô‡∏à‡∏±‡∏Å‡∏£‡∏¢‡∏≤‡∏ô
        osm_path_end = find_route_osm(road, start_station, end_station, 'a_star')
        if osm_path_end:
            complete_path.extend(osm_path_end[1:])  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡πÄ‡∏ä‡πà‡∏≤‡πÅ‡∏•‡∏∞‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡∏Ñ‡∏∑‡∏ô

        # ‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡∏Ñ‡∏∑‡∏ô‡∏à‡∏±‡∏Å‡∏£‡∏¢‡∏≤‡∏ô‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á
        osm_path_dest = find_route_osm(road, end_station, dest_pos, 'a_star')
        if osm_path_dest:
            complete_path.extend(osm_path_dest[1:])  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡∏Ñ‡∏∑‡∏ô‡πÅ‡∏•‡∏∞‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á

        # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå‡∏Ç‡∏≠‡∏á agent ‡∏Ñ‡∏ô‡∏ô‡∏µ‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÉ‡∏ô‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏Ç‡∏≠‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
        full_paths_a_star.append(complete_path)

        # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ä‡πà‡∏ß‡∏á‡∏Ç‡∏≠‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á (segments)
        boundaries = compute_segment_boundaries(complete_path, t_per_meter, simulation_time_step)

        # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≥‡∏ô‡∏ß‡∏ô time steps ‡∏ó‡∏µ‡πà agent ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
        active_steps = boundaries[-1]
        if active_steps > max_time_step:
            active_steps = max_time_step
        agent_grid_steps.append(active_steps)

        # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏´‡∏ï‡∏∏‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πà‡∏≤‡πÅ‡∏•‡∏∞‡∏Ñ‡∏∑‡∏ô‡∏à‡∏±‡∏Å‡∏£‡∏¢‡∏≤‡∏ô
        station_index = station_locations.index(start_station)
        end_station_index = station_locations.index(end_station)
        rental_events.append((boundaries[1], station_index))
        return_events.append((boundaries[-2], end_station_index))

        # ‡∏õ‡∏£‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏±‡∏Å‡∏£‡∏¢‡∏≤‡∏ô‡πÉ‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ
        initial_station_bikes[station_index] -= 1
        initial_station_bikes[end_station_index] += 1



    st.write("### a_star: ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Grid Steps ‡∏ó‡∏µ‡πà‡πÅ‡∏ï‡πà‡∏•‡∏∞ Agent ‡πÄ‡∏î‡∏¥‡∏ô")
    for idx, steps in enumerate(agent_grid_steps):
        st.write(f"Agent {idx+1}: {steps} grid steps")


    # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ç‡∏≠‡∏á agent ‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞ time step ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ compute_agent_timeline
    agents_positions_a_star = []
    for path in full_paths_a_star:
        timeline = compute_agent_timeline(path, t_per_meter, simulation_time_step, max_time_step)
        agents_positions_a_star.append(timeline)


    # ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏±‡∏Å‡∏£‡∏¢‡∏≤‡∏ô‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡∏ï‡∏•‡∏≠‡∏î timeline
    station_bikes_timeline = [[num_bikes_per_station] * len(station_locations) for _ in range(max_time_step)]
    for t in range(max_time_step):
        for rental_time, station_index in rental_events:
            if t >= rental_time:
                station_bikes_timeline[t][station_index] -= 1
        for return_time, station_index in return_events:
            if t >= return_time:
                station_bikes_timeline[t][station_index] += 1

    print("Station bikes at time 0:", station_bikes_timeline[0])
    print("Station bikes at final time:", station_bikes_timeline[-1])


    # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î CSS
    map_style = """
    <style>
        .stVerticalBlock { width: 80% !important; }
        .st-emotion-cache-17vd2cm { width: 80% !important; }
        [data-testid="stAppViewContainer"] { }
        [data-testid="stIFrame"] { width: 80% !important; height: 650px !important; }
        [data-testid="stMainBlockContainer"] { width: 80% !important; max-width: 80% !important; }
    </style>
    """
    st.markdown(map_style, unsafe_allow_html=True)
    

    # ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• A* ‡πÑ‡∏õ‡∏™‡∏£‡πâ‡∏≤‡∏á map
    st.write("### A* Traffic Simulation Map")
    traffic_map_a_star = create_map(full_paths_a_star, agents_positions_a_star, station_locations, 
                                 [[num_bikes_per_station]*len(station_locations) for _ in range(max_time_step)],
                                 destination_positions, road)
    with st.container():
        components.html(traffic_map_a_star._repr_html_(), height=600)



    # ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞
    print("ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞")
    # Run CBS algorithm
    print("Starting CBS...")
    cbs_solution, cbs_timelines, cbs_grid_steps = cbs_search(
        graph,
        start_positions,
        destination_positions,
        station_locations,
        t_per_meter,
        simulation_time_step,
        max_time_step,
        road
    )
    print("CBS finished!")

    # if cbs_solution:
    # Display grid steps for CBS
    st.write("### CBS: ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Grid Steps ‡∏ó‡∏µ‡πà‡πÅ‡∏ï‡πà‡∏•‡∏∞ Agent ‡πÄ‡∏î‡∏¥‡∏ô")
    
    if cbs_solution:
        for agent_id, steps in cbs_grid_steps.items():
            st.write(f"Agent {agent_id+1}: {steps} grid steps")
        
        # Convert CBS solution to format needed for visualization
        full_paths_cbs = list(cbs_solution.values())
        agents_positions_cbs = list(cbs_timelines.values())
        
        # Create CBS visualization
        st.write("### CBS Traffic Simulation Map")
        traffic_map_cbs = create_map(
            full_paths_cbs,
            agents_positions_cbs,
            station_locations,
            [[num_bikes_per_station]*len(station_locations) for _ in range(max_time_step)],
            destination_positions, road
        )
        with st.container():
            components.html(traffic_map_cbs._repr_html_(), height=600)
    else:
        st.write("CBS could not find a valid solution with the given constraints")




    print("ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞")
    m_star_solution, m_star_timelines, m_star_grid_steps = m_star_search(
        graph,
        start_positions,
        destination_positions,
        station_locations,
        t_per_meter,
        simulation_time_step,
        max_time_step,
        road
    )
    print("M* finished!")

    # Display M* results
    st.write("### M*: ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Grid Steps ‡∏ó‡∏µ‡πà‡πÅ‡∏ï‡πà‡∏•‡∏∞ Agent ‡πÄ‡∏î‡∏¥‡∏ô")
    for agent_id, steps in m_star_grid_steps.items():
        st.write(f"Agent {agent_id+1}: {steps} grid steps")

    # Visualize M* results
    st.write("### M* Traffic Simulation Map")
    traffic_map_m_star = create_map(
        list(m_star_solution.values()),
        list(m_star_timelines.values()),
        station_locations,
        [[num_bikes_per_station]*len(station_locations) for _ in range(max_time_step)],
        destination_positions, road
    )
    with st.container():
        components.html(traffic_map_m_star._repr_html_(), height=600)





    # def show_statistics(agent_grid_steps_abs, agent_grid_steps_cbs):
    # print("list(m_star_grid_steps.values())", list(cbs_grid_steps.values()))
    # print("list(m_star_grid_steps.values())", list(m_star_grid_steps.values()))
    show_statistics(agent_grid_steps, list(cbs_grid_steps.values()),  list(m_star_grid_steps.values()))

    # def show_summary_chart_plotly(agent_grid_steps_abs, agent_grid_steps_cbs):
    show_summary_chart_plotly(agent_grid_steps, list(cbs_grid_steps.values()), list(m_star_grid_steps.values()))

    # # def show_comparison_table(agent_grid_steps_a_star, cbs_grid_steps):
    show_comparison_table(agent_grid_steps, cbs_grid_steps, m_star_grid_steps)


    # # def compare_agent(agent_grid_steps_a_star, cbs_grid_steps, start_positions, destination_positions, station_locations):
    compare_agent(agent_grid_steps, cbs_grid_steps, m_star_grid_steps, start_positions, destination_positions, station_locations)












# ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞ü™©ü´ßüç∏ü•Çü´ß‚úßÀñ¬∞
if "rerun_done" not in st.session_state:
    if "max_time_step_input" in st.session_state:
        del st.session_state["max_time_step_input"]
        st.session_state["rerun_done"] = True  # ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ rerun ‡∏ã‡πâ‡∏≥‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏¢‡πÜ
        st.rerun()


# ‡∏™‡∏£‡πâ‡∏≤‡∏á Sidebar
with st.sidebar:
    st.header("Configuration")
    st.number_input("Max Time Steps:", min_value=1, value=500, key='max_time_step_input')
    st.number_input("Number of Bicycles in the Station:", min_value=1, value=10, key='num_bikes')
    option = st.radio("Population", ("Total Population", "Random Population Range"))
    # with st.container():
    #     if option == "Total Population":
    #         # ‡πÉ‡∏ä‡πâ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏Å‡∏£‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏ß‡πâ‡πÅ‡∏ô‡πà‡∏ô‡∏≠‡∏ô
    #         total_population = st.number_input("Total Population:", min_value=1, value=5, key='num_persons')
    #         if 'population' not in st.session_state:
    #             st.session_state.population = total_population
    #         else:
    #             st.session_state.population = total_population
    #     else:
    #         # ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡πà‡∏ß‡∏á‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏Å‡∏£‡πÅ‡∏•‡∏∞‡∏™‡∏∏‡πà‡∏°‡∏Ñ‡πà‡∏≤
    #         min_pop = st.number_input("Minimum Population:", min_value=1, value=5, key='min_pop')
    #         max_pop = st.number_input("Maximum Population:", min_value=min_pop, value=50, key='max_pop')
            
    #         if st.button("Generate Random Population", key='gen_random_pop'):
    #             random_pop = random.randint(min_pop, max_pop)
    #             st.session_state.population = random_pop
    #             st.success(f"Random population generated: {random_pop}")

    # ‡πÅ‡∏™‡∏î‡∏á UI ‡∏ï‡∏≤‡∏°‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
    if option == "Total Population":
        # ‡πÅ‡∏ö‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏ô‡πà‡∏ô‡∏≠‡∏ô
        st.session_state.population = st.number_input("Total Population:", min_value=1, value=5, key='num_persons')
    else:
        # ‡πÅ‡∏ö‡∏ö‡∏™‡∏∏‡πà‡∏°‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
        min_pop = st.number_input("Minimum Population:", min_value=1, value=5, key='min_pop')
        max_pop = st.number_input("Maximum Population:", min_value=min_pop, value=50, key='max_pop')
        
        if st.button("Generate Random Population", key='gen_random_pop'):
            random_pop = random.randint(min_pop, max_pop)
            st.session_state.population = random_pop
            st.success(f"Random population generated: {random_pop}")
            
        # ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡πà‡∏≤‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏Å‡∏£‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏Ñ‡∏¢‡∏™‡∏∏‡πà‡∏°‡πÅ‡∏•‡πâ‡∏ß)
        if option == "Random Population Range":
            st.write(f"Current population: {st.session_state.population}")

    col1, col2, col3 = st.sidebar.columns([1, 2, 1])
    with col2:  
        run_sim_bttn = st.button("Run Simulation")

# 5Ô∏è‚É£ ‡∏™‡πà‡∏ß‡∏ô‡∏≠‡∏¥‡∏ô‡∏û‡∏∏‡∏ï Streamlit
st.title("Bicycle Sharing Simulation")
st.write("Fill in the simulation details and press Run simulation to view the simulation results.")

if run_sim_bttn:
    run_simulation()



